# アセンブリ入門

> 作成日時 火曜日 21 12月 2021

ネイティブなバイナリを出力するコンパイラは機械語ではなく、通常アセンブリを出力する

## 逆アセンブル入門

* `.intel_syntax noprefix`
  > アセンブリの文法を指定する命令
* `.globl plus, main`
   > plus, main への参照を外部に公開するディレクティブ

## コマンド入門

rsiの値を rsi+rdi で上書きする

```x64
add rsi, rdi   // Intel
add %rdi, %rsi // AT&T
```

rsi の値を rax に*コピー*（移動したわけじゃない）

```x64
mov rax, 8     // Intel
mov $8, %rax   // AT&T
```

* call <引数>
   1. callの次の命令（例えばret）のアドレスをスタックにプッシュ
   2. callの引数として与えられたアドレスにジャンプ
      1. Cの場合、関数名はそのまま引数になる
* ret：
   1. スタックからアドレスを1つポップ
   2. そのアドレスにジャンプ

## 記法選別

```x64
mov rbp, rsp   // Intel
mov %rsp, %rbp // AT&T

mov rax, 8     // Intel
mov $8, %rax   // AT&T

mov [rbp + rcx * 4 - 8], rax // Intel
mov %rax, -8(rbp, rcx, 4)    // AT&T
```

## レジスタ入門

1. RAX：とりあえず、関数の返り値が入っている約束になっている
2. RDI：第一引数をもらう約束になっている
3. RSI：第二引数をもらう約束になっている

## スタック入門

1. 役割：関数処理が終了した後に、「リターンアドレス」という元々実行していたアドレスの保存
2. 手段：スタックトップを「スタックポインタ」に保持させる
   1. 通常、スタックポインタ専用のレジスタが使用される
   2. push と pop でそれぞれスタックにデータを積んだり取り出したりできる
3. call <引数>
   1. callの次の命令（例えばret）のアドレスをスタックにプッシュ
   2. callの引数として与えられたアドレスにジャンプ
4. ret：
   1. スタックからアドレスを1つポップ
   2. そのアドレスにジャンプ
