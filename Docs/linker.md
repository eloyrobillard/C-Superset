# リンカ

## 分割コンパイルの必要性

* 分割コンパイルしない場合、例えば printf を毎回コンパイルする必要になる -> 時間と処理の無駄
* 一方、一回 printf を .o にコンパイルすれば、その後はコンパイルせずに使える

つまり、翻訳単位を増やすたび、そこで更新したファイルだけ再コンパイルすればコンパイル時間が大幅に省ける。

## リンカの歴史

1947年にJohn Mauchlyチーム（最初のデジタルコンピュータ、ENIACのプロジェクトリーダー）は、テープから読み込んだサブプログラムを扱っていた。汎用的なサブルーチンを一回だけ書いて、他のプログラムで利用可能にしたかったため、イギリスのEDSACで最初のアセンブラが開発された前にすでにリンカを使っていた。

## 関数の外部参照

コードは別のCファイルに入っている関数を呼び出すとする。

1. それが関数の名前だという情報をコンパイラに渡す
2. エラーチェックのために引数の型と個数も渡す
3. 宛先の関数のコンパイルは無用：呼び出し元からすると、ただの ret だ
4. callで飛ぶ先のアドレスは分割コンパイル時にはわからないため、とりあえずアドレス0への call 命令を出力する
5. アセンブラはオブジェクトファイルに次の情報を残す：
   1. 飛び先関数は向こうのオブジェクトファイルの何バイト目に存在する
   2. 飛び先関数の名前
6. 「リロケート操作」：リンク時にリンカはジャンプ先のアドレスを修正する

上記をまとめると、飛び先関数の中身はいらないので、ただの「宣言」で良い。

``` c
(extern) int strncmp(const char *s1, const char *s2, size_t n);
```

関数の宣言と定義が区別されるため、**実際、extern を書かなくていい**

## ヘッダーファイルの必要性

関数、構造体、typedefなどといった宣言を複数のファイルで使いたい際はヘッダーに載せなくてはならない。

逆に複数のファイルに同じ宣言を乗せると管理が大変なことになりかねない。

## 前方方言の必要性（？）

前方方言を使って、ファイル全体を読み込まずに関数等を次々とコンパイルできる。

メインメモリが非常に小さかった時代には意味がありました。
