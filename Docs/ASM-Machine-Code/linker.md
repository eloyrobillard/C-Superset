# リンカ

## 分割コンパイルの必要性

* 分割コンパイルしない場合、例えば printf を毎回コンパイルする必要になる -> 時間と処理の無駄
* 一方、一回 printf を .o にコンパイルすれば、その後はコンパイルせずに使える

つまり、翻訳単位を増やすたび、そこで更新したファイルだけ再コンパイルすればコンパイル時間が大幅に省ける。

## リンカの歴史

1947年にJohn Mauchlyチーム（最初のデジタルコンピュータ、ENIACのプロジェクトリーダー）は、テープから読み込んだサブプログラムを扱っていた。汎用的なサブルーチンを一回だけ書いて、他のプログラムで利用可能にしたかったため、イギリスのEDSACで最初のアセンブラが開発された前にすでにリンカを使っていた。

## 関数の外部参照

コードは別のCファイルに入っている関数を呼び出すとする。

1. それが関数の名前だという情報をコンパイラに渡す
2. エラーチェックのために引数の型と個数も渡す
3. 宛先の関数のコンパイルは無用：呼び出し元からすると、ただの ret だ
4. callで飛ぶ先のアドレスは分割コンパイル時にはわからないため、とりあえずアドレス0への call 命令を出力する
5. アセンブラはオブジェクトファイルに次の情報を残す：
   1. 飛び先関数は向こうのオブジェクトファイルの何バイト目に存在する
   2. 飛び先関数の名前
6. 「リロケート操作」：リンク時にリンカはジャンプ先のアドレスを修正する

上記をまとめると、飛び先関数の中身はいらないので、ただの「宣言」で良い。

``` c
(extern) int strncmp(const char *s1, const char *s2, size_t n);
```

関数の宣言と定義が区別されるため、**実際、extern を書かなくていい**

## グローバル変数の外部参照

次の点２つを除き、グローバル変数の外部参照は関数のとほとんど変わらない：

1. 引数に関する情報を渡す必要はない
2. デフォルトでは実行禁止メモリ領域に割り付けられるので、そこにジャンプするとセグメンテーションフォールトになる

### データをコードとして実行する

次の main 文字列を定義するとしよう。中身はx86-64の機械語である：

``` c
// foo.c
char main[] = "\x48\xc7\xc0\x2a\x00\x00\x00\xc3";
```

以上のオブジェクトファイルを生成（`cc -c foo.c`）し、`objdump -D -M intel foo` を実行すると：

``` nasm
Disassembly of section .data:

0000000000000000 <main>:
   0:   48 c7 c0 2a 00 00 00    mov    rax,0x2a
   7:   c3     
```

さらに次を実行すると実行禁止領域というデフォルト動作を中止し、コードを実行できる：

``` bash
cc -static -Wl,--omagic -o foo foo.o
```

関変数の名前はただのラベルなので、そもそもデータとコードを区別しないリンカからみると main は変数だとしても構わない。

``` bash
$ ./foo
$ echo $?
42
```

## ヘッダーファイルの必要性

関数、構造体、typedefなどといった宣言を複数のファイルで使いたい際はヘッダーに載せなくてはならない。

逆に複数のファイルに同じ宣言を乗せると管理が大変なことになりかねない。

## 前方方言の必要性（？）

前方方言を使って、ファイル全体を読み込まずに関数やグローバル変数を次々とコンパイルできる。

メインメモリが非常に小さかった時代には意味がありました。
