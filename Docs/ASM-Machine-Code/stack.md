# スタック入門

## 注意

x86-64（そしてほとんどのCPU）の場合、スタックは下へ伸びる。
> 高いアドレスから低いアドレスへ伸びる

そのため、ローカル変数のアドレスを参照するには RSP から nバイト分を**引く**必要がある：

``` nasm
sub rsp, 16   ; RSP-16=ある変数のアドレス
```

### 理由

通常、実行は0のような下位アドレスから始まる。

* コードはそのした（マイナスのアドレス）に置かれる
* スタックがコードと混ざらないようにスタックベースをなるべく離れたところに置く
* そこで、上へ伸びることはできず、下位方向になる

## 命令

* 役割：関数処理が終了した後に、「リターンアドレス」という元々実行していたアドレスの保存
* 手段：スタックトップを「スタックポインタ」に保持させる
   1. 通常、スタックポインタ専用のレジスタが使用される
   2. push と pop でそれぞれスタックにデータを積んだり取り出したりできる

1. call <引数>
   1. callの次の命令（例えばret）のアドレスをスタックにプッシュ
   2. callの引数として与えられたアドレスにジャンプ
2. ret：
   1. スタックからアドレスを1つポップ
   2. そのアドレスにジャンプ
3. push <値・レジスタ>
   1. スタック上に引数を乗せる
   2. `push rax`は次の動作と同じ
   3. ``` c
      sub rsp, 8
      mov [rsp], rax
      ```
4. pop <レジスタ>
   1. スタックをポップし、戻り値を<レジスタ>に保存する
   2. `pop rax`は次の動作と同じ
   3. ``` c
      mov rax, [rsp]
      add rsp, 8
      ```
5. mov dst, [src]
   1. src をスタック内アドレスとみなし、そこにある値を dst にコピー

## アクチベーションレコード

または「関数フレーム」といい、関数呼び出しごとに確保されるメモリ領域のことである。

| after: call <fn_name> |     |
| --- | --- |
|リターンアドレス | <- RSP |

サイズ8バイトのローカル変数（aとb）を加えると：

| ... |     |
| --- | --- |
|リターンアドレス | |
| a | |
| b | <- RSP |

## ベースレジスタ

| ⬆️スタックの基へ |     |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | <- RBP |
| a | |
| b | <- RSP |

関数内で他の関数を呼び出すと次の表になる：

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | |
| a | |
| b | |
|gのリターンアドレス | |
|gの呼び出し時点のRBP | <- RBP |
| x | |
| y | <- RSP |

この場合：

* y -> RBP - 8バイト分
* X -> RBP - 16バイト分

## プロローグ

RBPとRSPのセットアップ

``` nasm
push rbp      ; 親関数に戻れるため
mov rbp, rsp
sub rsp, 16   ; x
```

``` nasm
call g
```

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | <- RBP |
| a | |
| b | |
|gのリターンアドレス | <- RSP |

``` nasm
push rbp
```

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | <- RBP |
| a | |
| b | |
|gのリターンアドレス | |
|gの呼び出し時点のRBP | <- RSP |

``` nasm
mov rbp, rsp
```

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | |
| a | |
| b | |
|gのリターンアドレス | |
|gの呼び出し時点のRBP | <- RSP, RBP |

``` nasm
sub rsp, 16
```

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | |
| a | |
| b | |
|gのリターンアドレス | |
|gの呼び出し時点のRBP | <- RBP |
| x | |
| y | <- RSP |

## エピローグ

``` nasm
mov rsp, rbp
pop rbp
ret
```

``` nasm
mov rsp, rbp
```

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | |
| a | |
| b | |
|gのリターンアドレス | |
|gの呼び出し時点のRBP | <- RBP, RSP |

``` nasm
pop rbp
```

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | <- RBP (popからもらった以前のアドレス) |
| a | |
| b | |
|gのリターンアドレス | <- RSP |
|~~gの呼び出し時点のRBP~~ (popされた) |  |

``` nasm
ret
```

callのメモ：

 1. スタックからレターんアドレスを1つポップ
 2. そのアドレスにジャンプ

注意すべき点は、retの暗黙的なpopを通じてでbに復元できた。

| ⬆️スタックの基へ |  |
| --- | --- |
|fのリターンアドレス | |
|fの呼び出し時点のRBP | <- RBP |
| a | |
| b | <- RSP |

gが呼び出される状態に無事復元された。
